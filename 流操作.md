# 简介

支持延迟计算,并行计算,支持过滤,查找,转换,汇总,聚合

# 运行机制

stream 分为 source, 中间操作, 终止操作

流的愿可以是数组集合 生成器方法 IO通道 

每个中间操作都会返回新流,供下一个操作

流只有遇到终止操作 它的愿才会开始执行遍历操作



# 流的创建

1. 通过数组:Stream.of()

   ```
   String[] str = {"a","b","c"};
   Stream<String> str1 = Stream.of(str)
   ```

2. 通过集合

   list.stream()

3. 通过Stream.generate() 

   ```java
   public static<T> Stream<T> generate(Supplier<T> s);
   @FunctionalInterface
   public interface Supplier<T> {
       T get();
   }
   ```

4. Stream.iterate方法

   ```java
   public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) 
   @FunctionalInterface
   public interface UnaryOperator<T> extends Function<T, T> {
       static <T> UnaryOperator<T> identity() {
           return t -> t;
       }
   }
   ```

5. 其他API

   ```java
   String str ="abc" ;
   IntStream chars = str.chars();
   chars.forEach(x->sout(x))
   ```

# 中间操作

1. filter 接收一个谓词(返回true,false)  返回符合谓词的流

   ```java
   List<Integer>il;
   il.stream().filter(i-> i%2 == 0);
   ```

2. distinct去重

   ```java
   List<Integer> il;
   il.stream().distinct().collect();
   ```

3. 排序

   ```java
   List<Integer> il;
   il.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList())
   ```

4. limit截取

   ```java
   List<Integer> il;
   i1.stream().limit(3).collect(Collectors.toList())
   ```

5. skip舍弃 舍弃前n个

   ```java
   List<Integer> il;
   il.stream().skip(n)
   ```

6. map归纳:将每个元素 映射成新的元素

   ```java
   List<Integer> il;
   il.stream().map(Dish::getName)
   ```

7. flatmap扁平化:把一个流中的每个值 换成另外一个流,把所有流都连接起来

   ```java
   Stringp[] words;
   Stream.of(words).map(w->w.split("")).flatMap(Arrays::stream).distinct().collect(Collectors.toList())
   ```

8. peek(): 执行动作之前执行一个动作

   

# 终止操作

1. 循环 foreach

2. 计算 min max count average

3. 匹配 anyMatch , allMatch , nonMatch, findFirst findAny

4. 汇聚 reduce 返回一个值

5. 收集collect

   1. 收集流中最大值,最小值,

      `Collectors.minBy(dishComparator)`

   2. 汇总

      `Collectors.summInt(Dish::getCalories)`

   3. 平均数

      `Collectors.averagingInt(Dish::getCarlories)`

   4. 连接字符串 joining

      `Collectors.joining(",")`

   5. 得到流的总数

      `Collectors.counting()`

   6. 分组

      `Collectors.groupingby(Dish::getType)`

   7. 多级分组

      Collectors.groupby(Dish::getType,Dish::getType1) 

   8. 按子组收集

      Collectors.groupingBy(Dish::getType,counting)
   
   

# 并行流

`Stream.iterate(1L,i->i+1).limit(n).parllel().reduce(0L,Long::sum)`





