# sql优化

* \> < <> 符号
  * <> 用 >或< 替换
  * \>= <= 要比 > < 要更准确   >=3,>2
* like符号
  * %放右边
* not in ,in
  * 用外连接替换
* where过滤顺序
  * 大的放右边,小的放左边

* 不索引空值
  * 避免使用空值,使用默认值替代,或者使用  > 或者 <替代
* sql语句的书写要保持一致,否则不会有执行计划的缓存
* 定期对表进行 统计信息分析 generate statics on <table>
* 函数处理的字段无法应用索引,  substr可以 替换成 like
* 进行显示或者隐式运算的字段 不能用索引,
  * df+20 > 50
  * rq+5 =sysdate
  * bh = 123456789 ,bh为字符串
* 条件双方包含本表字段运算时 不能索引
  * a>b
  * a||b= '123456'  -> 优化成 a='123' and b='456'



总结: compare,where,in,null,like,consistency,statics,function,explicit,double,union







# 哪些数据结构 哪些算法

常见的数据结构

一维:栈 ( 解析中缀表达式 ) ,队列,环,链表,线性表

二叉树:二叉排序树 ( huffman编码) ,平衡二叉树,红黑树(HashMap)

图: 邻接矩阵,十字链表,边集数组

几大排序算法



# 注解、泛型、异常、反射、常见设计模式?



# 多线程与锁

## 多线程之间为什么需要同步?

因为多线程同时 竞争一个资源时 会产生问题 也叫临界区

## 并发的级别

阻塞:悲观模式

无饥饿

无障碍:乐观模式,都不阻塞,一但出问题全部回滚

无锁:CAS

无等待

所有线程操作都是有限步骤



## Java线程基础知识

### 线程状态变更

new->runnable->running->wait,block by slow speed , blocked by sychornized block,wait  -> dead

### 线程的基本操作

start,stop,interrupt,wait,notify,suspend,resume,join,yield

### 线程组,守护线程

可以批量管理线程



## java同步解决方案

使用 synchronization

可重入锁

* 针对同一线程 可重入
* 公平性:效率低
* 超时特性
* 可中断
* 带有条件锁 wait,notify的封装

信号量

* acquire,acquireUninterruptible,tryAcquire
* release释放

读写锁

CountDownLatch

CyclicBarrier循环栅栏

设置栅栏点,到达点位后 执行某个任务

线程阻塞工具类 LockSupport ,类似于信号为1的信号量



## 线程池

关键参数

coreSize

maxSize

container

rejectHandler

线程池分类

根据 其针对 提交的 任务 的行为分类

* 直接提交的队列
* 有界队列
* 无界队列 
* 优先级队列

四种拒绝策略

* 直接抛异常
* 直接在调用者线程执行
* 丢弃最老的请求
* 丢弃该任务

可以自定义线程池

还可以扩展线程池:before,after,terminated



## 并发容器

ConcurrentHashMap:hash的分段锁

CopyOnWriteArrayList 读多写少:写时复制

ConcurrentLinkedQueue 高并发队列,内部使用CAS实现

BlockingQueue: 链表数组实现,数据共享通道



## 锁的优化及注意事项?

### 减小锁持有时间

​	减少锁定的代码,尽早释放锁

### 减小锁的粒度

​	就是缩小锁定对象的范围

​	例如concurrenthashMap, 可以只针对 一个 bucket 去加锁,但是获取全局信息例如 size方法性能会变差,你得全部先锁起来 

### 读写锁分离

### 锁分离

​	也可以叫做 操作分离:例如 对于Queue队列 的 take跟 put操作 他们两 互不影响,所可以 用两个锁而不是用一个锁

### 锁粗化

​	虚拟机会有 这种优化,一连串连续地对同一锁 不断进行请求和释放的操作,时,会把所有操作整合成对锁的一次请求,从而减少对锁的请求同步次数,

​	在for循环里 上锁, 应该 移到for循环外面去,这就是锁粗话

## JVM对锁优化的努力?

### 锁偏向

一个线程获得了锁,进入偏向模式,再次请求锁时无需任何同步操作,几乎没有竞争

如果不同的线程来请求相同的锁,偏向模式会失效 useBiaseLocking

### 轻量级锁

jvm会尝试 直接更新 锁对象的 某个标志字段,更新为LockRecord,而不需要申请操作系统层面的互斥量,记录锁状态为轻量级锁, 否则，说明已经有线程获得了轻量级锁, 目前发生了锁竞争,接下来膨胀为重量级锁

### 重量级锁

监视器锁 可以认为是 底层操作系统的互斥量, 同步成本很高,包括系统调用引起的内核态,用户态切换,线程阻塞造成的线程切换

### 自旋锁

通过自旋锁，可以减少线程阻塞造成的线程切换

### 自适应自旋锁

根据以往的自旋成功率 决定这次 自旋时间的长短

### 锁消除

消除错误的加锁

例如 局部变量加锁



## ThreadLocal 线程私有变量

## 无锁:CAS















# NIO与netty?





# 业务流水号的生成，字符串过滤，日志配置

ok

# SSM

## IOC容器

BeanFactory不常用，常用ApplicationContext 三个实现

## springbean

1. springBean定义
2. 生命周期
3. 后置处理器 在初始化前后可以加方法
4. bean可以继承
5. bean依赖注入的方式
6. bean装配的写法
   1. xml手动装配
   2. 注解自动装配
7. bean定义的方式
   1. xml配置
   2. 注解定义bean

## spring事件处理

refresh,start,stop,close,requethandled

事件发布：ApplicationEventPublisher

事件本身：ApplicationEvent

事件处理：implements ApplicationListener

## springAOP

概念:aspect->pointcut->advice

通知类型:前后，成功，失败，环绕	

## SpringJDBC

* 会使用JDBCTemplate

* DriverManagerDataSource

* queryInt,long,String,Object,List,update:DML,execute:DDL

## 事务管理

* 概念：ACID

* 抽象

  管理者:PlatformTransactionManager ,得到事务，提交事务，回滚事务

  事务定义:传播行为，隔离等级，标识符，是否是只读

  事务：是否完成，是否有保存点，是否是新事务

* 隔离等级
* 传播行为





敏捷开发









# 敏捷开发

scrum3.0



## 使用redis做啥

# activityMQ?

# codeReview?

### 