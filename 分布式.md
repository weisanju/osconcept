# 分布式事务

## 分布式事务产生原因

- 数据库分库分表
- SOA 架构

## 应用场景与解决方案

银行开户场景:手动实现的二阶段提交的协议，统计权值

消息中间件：

# 负载均衡的算法与实现

## 算法

顺序、加权轮询

最少连接算法（least Connections）：将请求发送给当前最少连接数的服务器

加权最小连接：在最小连接的基础上，根据服务器的性能为每台服务器分配权重，根据权重计算出每台服务器能处理的连接数。

随机算法（Random）：该算法比较适合服务器性能差不多的场景

## 实现

DNS负载均衡

链路层负载均衡器

修改IP负载均衡

HTTP 重定向

反向代理

# 分布式锁

Java 提供了两种内置的锁的实现，一种是由 JVM 实现的 synchronized 和 JDK 提供的 Lock

当你的应用是单机或者说单进程应用时，可以使用 synchronized 或 Lock 来实现锁

## 使用场景

应用端 、web端同时进行操作

## 数据库分布式锁

* 基于mysql锁表

  * 依靠数据库唯一索引来实现
  * 没有失效时间，会导致死锁
  * 只能是非阻塞
  * 不可重入

* 乐观锁增加版本号

  根据版本号来判断更新之前有没有其他线程更新过，如果被更新过，则获取锁失败。

## Redis 分布式锁

* 基于 SETNX、EXPIRE

  * 使用 SETNX（set if not exist）命令插入一个键值对时，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True
  * EXPIRE 可以为一个键值对设置一个过期时间，从而避免了死锁的发生。

* RedLock 算法

  * ReadLock 算法使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时还可用。
  * 尝试从 N 个相互独立 Redis 实例获取锁，如果一个实例不可用，应该尽快尝试下一个。
  * 计算获取锁消耗的时间，只有当这个时间小于锁的过期时间，并且从大多数（N/2+1）实例上获取了锁，那么就认为锁获取成功了。
  * 如果锁获取失败，会到每个实例上释放锁。

* Zookeeper 分布式锁

  * Zookeeper 提供了一种树形结构级的命名空间

  * 节点类型

    - 永久节点：不会因为会话结束或者超时而消失；
    - 临时节点：如果会话结束或者超时就会消失；
    - 有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，依次类推。

  * 监听器

    为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。

  * 分布式锁实现
    * 创建一个锁目录 /lock。
    * 在 /lock 下创建临时的且有序的子节点，第一个客户端对应的子节点为 /lock/lock-0000000000，第二个为 /lock/lock-0000000001，以此类推。
    * 客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；
    * 执行业务代码，完成后，删除对应的子节点。
  * 会话超时
    * 如果一个已经获得锁的会话超时了，因为创建的是临时节点，因此该会话对应的临时节点会被删除，其它会话就可以获得锁了
  * 羊群效应
    * 只需要监听前一个子节点

# 分布式 Session

## 粘性 Session

* 场景

  将用户锁定到某一个服务器上，用户第一次请求时，负载均衡器将用户的请求转发到了 A 服务器上，如果负载均衡器设置了粘性 Session 的话，那么用户以后的每次请求都会转发到 A 服务器上，相当于把用户和 A 服务器粘到了一块，这就是粘性 Session 机制。

* 优点

  简单，不需要对 Session 做任何处理。

* 缺点

  缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的 Session 信息都将失效。

* 适用场景

  - 发生故障对客户产生的影响较小；
  - 服务器发生故障是低概率事件。

## 服务器 Session 复制

* 任何一个服务器上的 Session 发生改变，该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要 Session，以此来保证 Session 同步

* 优点

  * 可容错，各个服务器间 Session 能够实时响应。

* 缺点

  会对网络负荷造成一定压力，如果 Session 量大的话可能会造成网络堵塞，拖慢服务器性能

* 实现方式

1. 设置 Tomcat 的 server.xml 开启 tomcat 集群功能。
2. 在应用里增加信息：通知应用当前处于集群环境中，支持分布式，即在 web.xml 中添加`<distributable/>` 选项。

## Session 共享机制

使用分布式缓存方案比如 Memcached、Redis，但是要求 Memcached 或 Redis 必须是集群。

*  粘性 Session 共享机制

  一个用户的 Session 会绑定到一个 Tomcat 上。Memcached 只是起到备份作用。

* 非粘性 Session 共享机制

  Tomcat 本身不存储 Session，而是存入 Memcached 中。Memcached 集群构建主从复制架构。

* 实现方式

  用开源的 msm 插件解决 Tomcat 之间的 Session 共享：Memcached_Session_Manager（MSM）

## Session 持久化到数据库

拿出一个数据库，专门用来存储 Session 信息。保证 Session 的持久化。

* 优点

  服务器出现问题，Session 不会丢失

* 缺点

  如果网站的访问量很大，把 Session 存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。

## Terracotta 实现 Session 复制

Terracotta 的基本原理是对于集群间共享的数据，当在一个节点发生变化的时候，Terracotta 只把变化的部分发送给 Terracotta 服务器，然后由服务器把它转发给真正需要这个数据的节点。它是服务器 Session 复制的优化。